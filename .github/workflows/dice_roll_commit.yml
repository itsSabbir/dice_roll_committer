# .github/workflows/dice_roll_commit.yml
name: Hourly Dice Roll Commit

on:
  schedule:
    # Run at the start of every hour.
    - cron: '0 * * * *'
  workflow_dispatch: # Allows manual triggering for testing.

# Concurrency control is critical for scheduled workflows to prevent race conditions.
# This ensures only one instance of the workflow runs at a time for a given branch.
# 'cancel-in-progress: true' will cancel any older, still-running instance.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  dice-roll-and-commit:
    runs-on: ubuntu-latest
    
    # Define permissions explicitly. 'contents: write' is for pushing commits,
    # and 'actions: write' can be used for more advanced interactions if needed.
    permissions:
      contents: write

    # Centralize configuration in the 'env' block for maintainability.
    env:
      PYTHON_VERSION: '3.11'
      GIT_AUTHOR_NAME: "Sabbir Hossain"
      GIT_AUTHOR_EMAIL: "hossain.sabbir17@gmail.com"
      LOG_FILENAME: "dice_roll_log.txt"
      COMMIT_MSG_FILENAME: "commit_message.txt"

    steps:
      # Step 1: Checkout Repository
      # 'fetch-depth: 0' is crucial here. It fetches the entire git history, which is
      # necessary for 'git pull --rebase' to work correctly and avoid conflicts.
      # A shallow clone (the default) can cause rebasing to fail.
      - name: 1. Checkout repository with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Step 2: Set up Python Environment
      - name: 2. Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # Step 3: Execute Dice Roll Committer Script
      # This is the core decision-making step. The Python script will exit with:
      # - 0: If a commit is recommended.
      # - 1: On a critical error.
      # - 2: If no commit was decided (clean exit).
      # We use 'continue-on-error: true' to allow the workflow to proceed regardless
      # of the exit code, so we can analyze the outcome in the next steps.
      - name: 3. Run Dice Roll Committer script
        id: dice_roll_script
        run: python dice_roll_committer.py
        continue-on-error: true

      # Step 4: Evaluate Script Outcome and Prepare for Commit
      # This step acts as a router based on the script's exit code.
      # It sets outputs that control whether the subsequent commit steps run.
      - name: 4. Evaluate script outcome
        id: evaluation
        run: |
          echo "Python script exited with outcome: ${{ steps.dice_roll_script.outcome }}"
          # The script's outcome is 'success' only if it exited with 0.
          if [[ "${{ steps.dice_roll_script.outcome }}" == "success" ]]; then
            echo "✅ Script recommended a commit. Proceeding to commit steps."
            echo "should_commit=true" >> $GITHUB_OUTPUT

            # --- THE FIX ---
            # Instead of using 'cat' directly, read the file's content into a shell
            # variable first. Then, echo that variable into the heredoc.
            # This is more robust and prevents issues with missing newlines at the end of the file.
            COMMIT_MSG_CONTENT=$(cat ${{ env.COMMIT_MSG_FILENAME }})
            echo "commit_message<<EOF" >> $GITHUB_OUTPUT
            echo "$COMMIT_MSG_CONTENT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
          else
            echo "❌ Script did not recommend a commit or an error occurred. Skipping commit steps."
            echo "should_commit=false" >> $GITHUB_OUTPUT
            echo "commit_message=N/A" >> $GITHUB_OUTPUT # Provide a default value
          fi

      # Step 5: Commit and Push Changes
      # This step ONLY runs if the evaluation step decided to proceed.
      # This 'if' condition is the gatekeeper for all git write operations.
      - name: 5. Commit and push changes
        if: steps.evaluation.outputs.should_commit == 'true'
        run: |
          echo "🚀 Starting commit and push process..."
          # Configure git user for this specific job.
          git config --local user.name "${{ env.GIT_AUTHOR_NAME }}"
          git config --local user.email "${{ env.GIT_AUTHOR_EMAIL }}"
          
          # Add all potentially changed files.
          git add ${{ env.LOG_FILENAME }} ${{ env.COMMIT_MSG_FILENAME }}
          
          # Before committing, perform a final check. This is a "trust but verify" safety net.
          # If git status is clean, something is wrong (e.g., script exited 0 but didn't write).
          if git diff --staged --quiet; then
            echo "⚠️ WARNING: Script recommended commit, but no file changes were staged. Aborting."
            # We exit non-zero to fail the job, as this indicates an inconsistent state.
            exit 1
          fi
          
          echo "Committing with the following message:"
          echo "--------------------------------------------------"
          echo "${{ steps.evaluation.outputs.commit_message }}"
          echo "--------------------------------------------------"
          
          # Commit using the message passed from the evaluation step.
          git commit -F ${{ env.COMMIT_MSG_FILENAME }}
          
          # Before pushing, synchronize with the remote branch using rebase.
          # This minimizes push conflicts if the remote was updated during the run.
          echo "Syncing with remote branch '${{ github.ref_name }}' using 'pull --rebase'..."
          git pull --rebase origin ${{ github.ref_name }}
          
          # Push changes with a retry loop to handle transient network issues.
          for i in 1 2 3; do
            echo "Push attempt #$i..."
            if git push origin ${{ github.ref_name }}; then
              echo "✅ Push successful on attempt #$i!"
              # Set an output for the summary step with the commit SHA.
              echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
              exit 0 # Success
            fi
            if [ $i -lt 3 ]; then
              echo "⚠️ Push attempt #$i failed. Retrying in 15 seconds..."
              sleep 15
            else
              echo "❌ CRITICAL: All push attempts failed. Manual intervention required."
              exit 1 # Failure
            fi
          done
        id: commit_step # Give this step an ID to access its outputs.

      # Step 6: Generate Job Summary
      # This step runs regardless of the outcome and provides a clean, human-readable
      # report in the GitHub UI, which is a massive quality-of-life improvement.
      - name: 6. Generate Job Summary
        run: |
          echo "## 🎲 Dice Roll Commit - Job Summary" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "Workflow run triggered at **$(date -u +"%Y-%m-%d %H:%M:%S UTC")**." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Case 1: A commit was successfully made.
          if [[ "${{ steps.evaluation.outputs.should_commit }}" == "true" && "${{ steps.commit_step.outcome }}" == "success" ]]; then
            echo "### ✅ Commit Successful" >> $GITHUB_STEP_SUMMARY
            echo "A new commit was successfully pushed to the repository." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Commit Details:**" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "${{ steps.evaluation.outputs.commit_message }}" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            COMMIT_URL="${{ github.server_url }}/${{ github.repository }}/commit/${{ steps.commit_step.outputs.commit_sha }}"
            echo "🔗 View commit: [${{ steps.commit_step.outputs.commit_sha }}](${COMMIT_URL})" >> $GITHUB_STEP_SUMMARY
          
          # Case 2: No commit was made as per the script's logic.
          elif [[ "${{ steps.evaluation.outputs.should_commit }}" == "false" ]]; then
            echo "### ⏩ No Commit Action Taken" >> $GITHUB_STEP_SUMMARY
            echo "The Python script decided not to make a commit on this run (Exit Code 2)." >> $GITHUB_STEP_SUMMARY
            echo "This is an expected and clean outcome based on the configured probabilities." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            # You can add more details here if needed by reading a potential 'no-commit-reason.txt' file
            
          # Case 3: A failure occurred.
          else
            echo "### ❌ Job Failed" >> $GITHUB_STEP_SUMMARY
            echo "The job failed to complete successfully. Please review the logs for details." >> $GITHUB_STEP_SUMMARY
            echo "**Last known outcome from script evaluation:** `${{ steps.dice_roll_script.outcome }}`" >> $GITHUB_STEP_SUMMARY
          fi
        # This step should always run to provide a report, even if prior steps failed.
        if: always()